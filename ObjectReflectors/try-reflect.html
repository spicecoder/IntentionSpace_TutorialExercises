<!DOCTYPE html>
<html>
<head>
  <title>Exercise 4.1: Object as Mirror</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      max-width: 800px; 
      margin: 50px auto;
      padding: 20px;
    }
    .section {
      border: 2px solid #ddd;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
    }
    .kitchen { background-color: #fff3cd; }
    .window { background-color: #d1ecf1; }
    .table { background-color: #d4edda; }
    
    .item {
      background: white;
      padding: 10px;
      margin: 10px 0;
      border-left: 4px solid #007bff;
      border-radius: 4px;
    }
    
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 10px;
    }
    .status.waiting { background-color: #ffc107; color: black; }
    .status.ready { background-color: #28a745; color: white; }
    .status.delivered { background-color: #6c757d; color: white; }
    
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background-color: #0056b3; }
    
    .concept-box {
      background-color: #e7f3ff;
      border-left: 4px solid #007bff;
      padding: 15px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // üîß STEP 1: Define what an Object looks like
    class DeliveryWindow {
      constructor() {
        // Objects have TEMPORARY PERSISTENCE
        this.heldItems = [];  // Holds dishes until ready to reflect
      }

      // Objects RECEIVE intentions
      receive(intention) {
        console.log('üì• Window received:', intention);
        
        // Store temporarily (PERSISTENCE)
        this.heldItems.push({
          ...intention,
          receivedAt: new Date().toLocaleTimeString()
        });
      }

      // Objects CHECK gatekeeper before reflecting
      checkGatekeeper(tableNumber) {
        // Gatekeeper condition: "Are all items for this table ready?"
        const tableItems = this.heldItems.filter(
          item => item.tableNumber === tableNumber
        );
        
        const allReady = tableItems.every(item => item.status === 'ready');
        
        console.log(`üö™ Gatekeeper check for Table ${tableNumber}:`, 
          allReady ? '‚úÖ PASS' : '‚ùå WAIT');
        
        return allReady;
      }

      // Objects REFLECT when gatekeeper passes
      reflect(tableNumber, onReflected) {
        // Check gatekeeper first
        if (!this.checkGatekeeper(tableNumber)) {
          console.log(`‚è≥ Not ready to reflect to Table ${tableNumber}`);
          return null;
        }

        // Gatekeeper passed - reflect!
        const itemsToReflect = this.heldItems.filter(
          item => item.tableNumber === tableNumber
        );

        console.log(`‚ú® Reflecting to Table ${tableNumber}:`, itemsToReflect);

        // Remove from held items (reflection complete)
        this.heldItems = this.heldItems.filter(
          item => item.tableNumber !== tableNumber
        );

        // ASYNCHRONOUS: Callback happens later
        if (onReflected) {
          onReflected(itemsToReflect);
        }

        return itemsToReflect;
      }

      // Helper: mark item as ready
      markReady(itemName) {
        const item = this.heldItems.find(i => i.dishName === itemName);
        if (item) {
          item.status = 'ready';
          console.log(`‚úÖ ${itemName} marked ready`);
        }
      }

      // Get current state (for display)
      getState() {
        return [...this.heldItems];
      }
    }

    // üîß STEP 2: Create the Object instance
    const deliveryWindow = new DeliveryWindow();

    // üîß STEP 3: Build the UI
    function RestaurantSystem() {
      const [windowState, setWindowState] = useState([]);
      const [deliveredItems, setDeliveredItems] = useState([]);
      const [log, setLog] = useState([]);

      const addLog = (message) => {
        setLog(prev => [...prev, `${new Date().toLocaleTimeString()}: ${message}`]);
      };

      // Simulate kitchen finishing a dish
      const finishDish = (dishName, tableNumber) => {
        // Kitchen sends intention to Object
        const intention = {
          intentionId: 'INT_DISH_READY',
          dishName,
          tableNumber,
          status: 'waiting'  // Not ready for reflection yet
        };

        deliveryWindow.receive(intention);
        setWindowState(deliveryWindow.getState());
        addLog(`Kitchen sent ${dishName} to window (Table ${tableNumber})`);
      };

      // Simulate item being marked ready
      const markItemReady = (dishName) => {
        deliveryWindow.markReady(dishName);
        setWindowState(deliveryWindow.getState());
        addLog(`${dishName} marked READY`);

        // Automatically try to reflect
        setTimeout(() => tryReflect(), 100);
      };

      // Try reflection (checks gatekeeper)
      const tryReflect = () => {
        // Get unique table numbers from window
        const currentState = deliveryWindow.getState();
        const tables = [...new Set(currentState.map(item => item.tableNumber))];

        if (tables.length === 0) {
          addLog('‚ÑπÔ∏è No items in window to reflect');
          return;
        }

        tables.forEach(tableNum => {
          const tableItems = currentState.filter(i => i.tableNumber === tableNum);
          const canReflect = deliveryWindow.checkGatekeeper(tableNum);
          
          if (canReflect) {
            // Gatekeeper passed - reflect!
            const reflected = deliveryWindow.reflect(tableNum, (items) => {
              setDeliveredItems(prev => [...prev, ...items]);
              addLog(`‚ú® REFLECTED ${items.length} items to Table ${tableNum} (Gatekeeper PASSED)`);
            });

            if (reflected) {
              setWindowState(deliveryWindow.getState());
            }
          } else {
            // Gatekeeper failed - log why
            const readyCount = tableItems.filter(i => i.status === 'ready').length;
            const totalCount = tableItems.length;
            addLog(`üö™ Table ${tableNum} Gatekeeper BLOCKED: ${readyCount}/${totalCount} items ready`);
          }
        });
      };

      return (
        <div>
          <h1>ü™û Exercise 4.1: Object as Mirror</h1>
          
          <div className="concept-box">
            <strong>Key Concept:</strong> The Delivery Window is an <strong>Object</strong>.
            <ul>
              <li>‚úÖ Receives intentions from Kitchen</li>
              <li>‚úÖ Holds them temporarily (persistence)</li>
              <li>‚úÖ Checks gatekeeper (all items ready?)</li>
              <li>‚úÖ Reflects when condition met (async)</li>
              <li>‚ùå Does NOT cook (no computation)</li>
            </ul>
          </div>

          {/* Kitchen Section */}
          <div className="section kitchen">
            <h2>üç≥ Kitchen (sends intentions)</h2>
            <button onClick={() => finishDish('Pasta', 3)}>
              Finish Pasta (Table 3)
            </button>
            <button onClick={() => finishDish('Salad', 3)}>
              Finish Salad (Table 3)
            </button>
            <button onClick={() => finishDish('Burger', 5)}>
              Finish Burger (Table 5)
            </button>
          </div>

          {/* Delivery Window (Object) */}
          <div className="section window">
            <h2>ü™ü Delivery Window (Object)</h2>
            <p><strong>Held Items:</strong> {windowState.length}</p>
            
            {windowState.length === 0 ? (
              <p style={{color: '#666'}}>No items waiting...</p>
            ) : (
              windowState.map((item, idx) => (
                <div key={idx} className="item">
                  <strong>{item.dishName}</strong> ‚Üí Table {item.tableNumber}
                  <span className={`status ${item.status}`}>
                    {item.status === 'waiting' ? 'WAITING' : 'READY'}
                  </span>
                  
                  {item.status === 'waiting' && (
                    <button onClick={() => markItemReady(item.dishName)}>
                      Mark Ready
                    </button>
                  )}
                  
                  <div style={{fontSize: '12px', color: '#666', marginTop: '5px'}}>
                    Received: {item.receivedAt}
                  </div>
                </div>
              ))
            )}

            <div style={{marginTop: '20px'}}>
              <strong>Gatekeeper Status:</strong>
              <ul>
                {[...new Set(windowState.map(i => i.tableNumber))].map(table => {
                  const tableItems = windowState.filter(i => i.tableNumber === table);
                  const allReady = tableItems.every(i => i.status === 'ready');
                  return (
                    <li key={table}>
                      Table {table}: {allReady ? '‚úÖ Can reflect' : '‚è≥ Waiting'}
                    </li>
                  );
                })}
              </ul>
            </div>

            <button 
              onClick={tryReflect}
              style={{
                backgroundColor: windowState.length === 0 ? '#ccc' : '#28a745',
                cursor: windowState.length === 0 ? 'not-allowed' : 'pointer'
              }}
              disabled={windowState.length === 0}
            >
              üîÑ Test Gatekeeper & Reflect
            </button>
            <p style={{fontSize: '12px', color: '#666', marginTop: '10px'}}>
              ‚ÑπÔ∏è Reflection happens automatically when items are marked ready, 
              but you can also test manually with this button.
            </p>
          </div>

          {/* Table Section */}
          <div className="section table">
            <h2>üçΩÔ∏è Tables (received reflections)</h2>
            {deliveredItems.length === 0 ? (
              <p style={{color: '#666'}}>No deliveries yet...</p>
            ) : (
              deliveredItems.map((item, idx) => (
                <div key={idx} className="item">
                  <strong>{item.dishName}</strong> delivered to Table {item.tableNumber}
                  <span className="status delivered">DELIVERED</span>
                </div>
              ))
            )}
          </div>

          {/* Event Log */}
          <div className="section">
            <h2>üìã Event Log</h2>
            <div style={{
              maxHeight: '200px', 
              overflowY: 'auto',
              fontFamily: 'monospace',
              fontSize: '12px',
              background: '#f8f9fa',
              padding: '10px',
              borderRadius: '4px'
            }}>
              {log.map((entry, idx) => (
                <div key={idx}>{entry}</div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<RestaurantSystem />, document.getElementById('root'));
  </script>
</body>
</html>